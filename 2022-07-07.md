## 1주차 목요일 수업
### 가장 가까운 시간
* HH:MM 식으로 입력이 되면 일단 분으로 환산해야 함
* 임의의 두 시간을 골랐을 때 시간의 차가 가장 작은 경우를 찾아야 함
* 정렬하여 인접한 두 시간의 차를 비교하고, 최소값을 찾음
* 첫 번째 오는 값과 마지막에 오는 값의 차도 구해야 하기 때문에, 초기값을 첫 번째 값과 마지막 값의 거리로 함
* 첫 번째 값과 마지막 값의 거리 = (24 * 60 + a) - b
* 문자열인 시간을 분으로 환산하기 위한 함수를 따로 작성하도록 함

		public class Main {

			// *** 시간을 분으로 환산하여 반환하는 함수
			public int getTime(String time) {
				String[] tmp = time.split(":");
				int hour = Integer.parseInt(tmp[0]);
				int minute = Integer.parseInt(tmp[1]);

				return hour * 60 + minute;
			}

			public int solution(String[] times) {
				ArrayList<Integer> tmp = new ArrayList<>();

				for(String time : times) {
					tmp.add(getTime(time));
				}

				// 정렬
				Collections.sort(tmp);

				int answer = (24 * 60 + tmp.get(0)) - tmp.get(tmp.size() - 1);

				for(int i = 1; i < tmp.size(); i++) {
					answer = Math.min(answer, tmp.get(i) - tmp.get(i-1));
				}

				return answer;
			}

			public static void main(String[] args) {		
				Main T = new Main();
				String[] tmp = new String[] {"00:12", "00:00", "01:05", "00:57"};
				System.out.println(T.solution(tmp));		
			}

		}	

### 공부 시간
	public class Main {

		// *** 시간을 분으로 환산하여 반환하는 함수
		public int getTime(String time) {
			String[] tmp = time.split(":");
			int hour = Integer.parseInt(tmp[0]);
			int minute = Integer.parseInt(tmp[1]);

			return hour * 60 + minute;
		}

		public String solution(String[] times) {		
			ArrayList<Integer> tmp = new ArrayList<>();

			for(String time : times) {
				tmp.add(getTime(time));
			}

			int sum = 0;
			for(int i = 0; i < tmp.size(); i+=2) {
				int data = tmp.get(i+1) - tmp.get(i);
				if(data < 5) sum += 0;
				else if(data >= 105) sum += 105;
				else sum += data;
			}

			int hour = sum / 60;
			int minute = sum % 60;

			return (hour<10?"0"+hour:hour) + ":" + (minute<10?"0"+minute:minute);
		}

		public static void main(String[] args) {		
			Main T = new Main();
			String[] tmp = new String[] {"08:30", "09:00", "14:00", "16:00", "16:01", "16:06", "16:07", "16:11"};
			System.out.println(T.solution(tmp));		
		}

	}

### 제곱수 정렬
	public int[] solution(int[] data) {
		int[] answer = new int[data.length];
		int left = 0;
		int right = data.length - 1;
		
		for(int i = data.length - 1; i >= 0; i++) {
			if(Math.abs(data[left]) < Math.abs(data[right])) {
				answer[i] = data[right] * data[right];
				right--;
			} else {
				answer[i] = data[left] * data[left];
			}
		}
		
		return answer;
	}
	
### 가장 높은 증가수열
	public int solution(int[] data) {
		int answer = 0;
		int height = 0;
		
		for(int i = 1; i < data.length; i++) {
			if(data[i] > data[i-1]) height += (data[i] - data[i-1]);
			else {
				answer = Math.max(answer, height);
				height = 0;
			}
		}
		answer = Math.max(answer, height); // 마지막 부분이 증가수열일 때
		
		return answer;
	}
	
### 바이토닉 수열 (마운틴 배열)
	public String solution(int[] data) {
		String answer = "YES";
		int i = 0;
		
		while(i+1 < data.length && data[i] < data[i+1]) i++;
		if(i == 0 || i == data.length - 1) return "NO";
		while(i+1 < data.length && data[i] > data[i+1]) i++;
		if(i != data.length - 1) return "NO";
		
		return answer;
	}

### 최대 길이 바이토닉
	public int solution(int[] data) {
		int answer = 0;
		ArrayList<Integer> peaks = new ArrayList<Integer>();
		int n = data.length;		
		
		for(int i = 1; i < n-1; i++) {
			if(data[i] > data[i-1] && data[i] > data[i+1])
				peaks.add(i);
		}
		
		for(int peak : peaks) {
			int left = peak, right = peak, cnt = 1;
			while(left-1 >= 0 && data[left-1] < data[left]) {
				cnt++; left--;
			}
			while(right+1 < n && data[right+1] < data[right]) {
				cnt++; right++;
			}
			answer = Math.max(answer, cnt);
		}
		
		return answer;
	}
	
### 수열의 경우수
	public int solution(int[] data) {
		int answer = 0;
		ArrayList<Integer> peaks = new ArrayList<Integer>();
		int n = data.length;		
		
		for(int i = 1; i < n-1; i++) {
			if(data[i] > data[i-1] && data[i] > data[i+1])
				peaks.add(i);
		}
		
		for(int peak : peaks) {
			int left = peak, right = peak, lcnt = 0, rcnt = 0;
			while(left-1 >= 0 && data[left-1] < data[left]) {
				lcnt++; left--;
			}
			while(right+1 < n && data[right+1] < data[right]) {
				rcnt++; right++;
			}
			answer += lcnt * rcnt;
		}
		
		return answer;
	}
	
### 거리 두기
	public int solution(int[] data) {
		int n = data.length;		
		
		int[] dist = new int[n];
		int cnt = Integer.MAX_VALUE;
		for(int i = 0; i < n; i++) {
			if(data[i] == 1) cnt = 0;
			else if(data[i] == 0) dist[i] = ++cnt;
		}
		cnt = Integer.MAX_VALUE;
		for(int i = n-1; i >= 0; i--) {
			if(data[i] == 1) cnt = 0;
			else if(data[i] == 0) dist[i] = Math.min(++cnt, dist[i]);
		}
		int answer = dist[0];
		for(int i = 1; i < n; i++) answer = (answer<dist[i])?dist[i]:answer;
		
		return answer;
	}
	
### 키보드
	public int solution(String s, int n) {
		int answer = 0;
		int[] used = new int[27];
		for(int x : s.toCharArray()) {
			if(x >= 65 && x <= 90) {
				used[26] = 1;
				used[x-65] = 1;
			}
			else if(x >= 97 && x <= 122) used[x-97] = 1;
		}
		int cnt = 0;
		for(int x : used)
			if(x == 1) cnt++;
		
		if(n == cnt) answer = s.length();
		else answer = -1;
		return answer;
	}
